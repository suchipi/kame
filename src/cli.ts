#!/usr/bin/env node
import fs from "fs";
import path from "path";
import chalk from "chalk";
import yargsParser from "yargs-parser";
import { configure } from "./index";
import { InputConfig } from "./config";

const argv = yargsParser(process.argv.slice(2), {
  boolean: ["help"],
  string: [
    "input",
    "output",
    "global",
    "loader",
    "resolver",
    "runtime-eval",
    "runtimeEval",
    "codeSplittingId",
    "code-splitting-id",
  ],
});

function getInput(argv): string {
  let input = argv.input || argv._[1];

  if (!input) {
    const pathsToTry = [
      path.join(process.cwd(), "src", "index.tsx"),
      path.join(process.cwd(), "src", "index.ts"),
      path.join(process.cwd(), "src", "index.jsx"),
      path.join(process.cwd(), "src", "index.js"),
      path.join(process.cwd(), "index.tsx"),
      path.join(process.cwd(), "index.ts"),
      path.join(process.cwd(), "index.jsx"),
      path.join(process.cwd(), "index.js"),
    ];

    let pathToUse: string | null = null;
    while (!pathToUse && pathsToTry.length > 0) {
      const nextPath = pathsToTry.shift();
      if (!nextPath) break;
      if (fs.existsSync(nextPath)) {
        pathToUse = nextPath;
      }
    }

    if (pathToUse) {
      input = pathToUse;
      console.warn(
        `Auto-detected '${path.relative(
          process.cwd(),
          pathToUse
        )}' as the input file. Use --input to override.`
      );
    } else {
      console.error(
        `Could not auto-detect the input file. Please specify it with --input.`
      );
      console.error(`Run with --help for more info.`);
      process.exit(1);
    }
  }

  return input;
}

function getOutput(argv): string {
  let output = argv.output || argv._[2];
  if (!output) {
    output = path.join(process.cwd(), "dist", "index.js");
    console.warn(
      `Using default output path of './dist/index.js'. Use --output to override.`
    );
  }

  return output;
}

const usage = `Usage: kame <command> [options] [inputfile] [outputfile]

<command>: What to do. Can be 'run' or 'bundle'.

___ Examples: ___

# Runs ./src/index.{tsx,ts,jsx,js} or ./index.{tsx,ts,jsx,js}, whichever exists
kame run

# Runs ./my-script.ts
kame run ./my-script.ts

# Runs ./my-script.ts (same as above)
kame run --input ./my-script.ts

# Bundles:
#   ./src/index.{tsx,ts,jsx,js} or ./index.{tsx,ts,jsx,js}, whichever exists
# into
#  ./dist/index.js
kame bundle

# Bundles ./my-library.ts into ./dist/my-library, and sets up the bundle so
# that if it's loaded in an environment without CommonJS/AMD (eg a browser),
# the exports of ./my-library.ts are put on the global 'MyLibrary'
kame bundle ./my-library.ts ./dist/my-library.js --global MyLibrary

# Run ./my-script.ts, using a custom loader (see \`--loader\` below)
kame run --loader ./my-loader.js --input ./my-script.ts

# Bundle ./my-script.ts, using a custom loader (see \`--loader\` below)
kame bundle --loader ./my-loader.js --input ./my-script.ts


___ Options: ___

--input: The entrypoint file to run/bundle.

  If left unspecified, kame will attempt to use whichever of these files
  exists, in order:

  - ./src/index.tsx
  - ./src/index.ts
  - ./src/index.jsx
  - ./src/index.js
  - ./index.tsx
  - ./index.ts
  - ./index.jsx
  - ./index.js



--output: The file to write bundle output to.

  This option is only used when bundling code via \`kame bundle\`, not when
  using \`kame run\`.

  If left unspecified, kame will default to './dist/index.js'.

  Note: If you use code splitting (dynamic import), then the split chunks will
  be written into the same folder as the output file, with autogenerated names.
  For this reason, you may want the output file to be in folder like 'dist' or
  'build'.



--global: The library global name for the UMD wrapper.

  This option is only used when bundling code via \`kame bundle\`, not when
  using \`kame run\`.

  This option specifies the name of the global variable that the bundle
  contents should be written to, if the bundle is loaded in an environment
  without a module loader. If you pass the string "null", then no global will
  be written.

  If left unspecified, no global variable will be written.



--loader: A custom loader function used to read/transform code.

  The path to a file that exports a loader function, which kame will use to
  read modules from disk and convert them to JavaScript.

  A loader module should export a function named "load" that receives a string
  (the file to load), and returns either a string (the code to execute) or a
  { code: string, map: any } object (containing both the code to execute and a
  sourcemap). Loader functions must be synchronous, because they're called when
  'require' is called.

  Note: source maps returned from loader modules not yet supported by
  \`kame bundle\`, only by \`kame run\`.

  Defaults to 'node_modules/kame/dist/default-loader.js', which supports
  ES2020, React, TypeScript, Flow, CSS, images, and more.

  If you want to write a loader that adds additional functionality on top of
  the default loader, or overrides functionality of the default loader, you can
  require the default loader into your loader module and call it as desired:

  \`\`\`
  const {defaultLoader} = require("kame");

  exports.load = function myLoad(file) {
    // whatever custom logic you want.
    // in this example, overriding the default css loading
    if (file.endsWith(".css")) {
      // return your own code in here
    }

    // and then default handling for everything else:
    return defaultLoader.load(file);
  };
  \`\`\`



--resolver: A custom resolver function used to resolve imports and requires.

  The path to a file that exports a resolver function, which kame will use to
  convert the strings appearing in requires and imports into absolute paths to
  files on disk.

  A resolver module should export a function named "resolve" that receives two
  arguments:
  - The string that appeared in the require/import
  - The absolute path to the file that that require/import was found in

  Defaults to 'node_modules/kame/dist/default-resolver.js', which implements
  node's module resolution algorithm, and supports omitting the extension in
  the import/require for any of these filetypes:

    ".js", ".json", ".mjs", ".jsx", ".ts", ".tsx", ".node"

  If you want to write a resolver that adds additional functionality on top of
  the default resolver, or overrides functionality of the default resolver, you
  can require the default resolver into your resolver module and call it as
  desired:

  \`\`\`
  const path = require("path");
  const {defaultResolver} = require("kame");

  exports.resolve = function myResolve(source, fromFile) {
    // whatever custom logic you want. in this example, a path alias
    if (source.startsWith("~")) {
      source = path.join(__dirname, source.replace("~", ""));
    }

    return defaultResolver.resolve(source, fromFile);
  };
  \`\`\`



--runtime-eval: A custom eval function used to run code.

  This option is only used when running code via \`kame run\`, not when
  bundling code via \`kame bundle\`.

  The path to a file that exports an 'evaluate' function, which kame will use
  to execute code (in run mode only).

  An eval module should export a function named "evaluate" that receives two
  arguments:
  - A code string (it will always be an expression)
  - The absolute path to the file where the code came from

  And should return:
  - The result of evaluating the code string

  Defaults to 'node_modules/kame/dist/default-runtime-eval.js', which uses
  node's builtin \`vm\` module to run code.

  If you want to write an eval module that adds additional functionality on top
  of the default eval module, or overrides functionality of the default eval
  module, you can require the default eval module into yours and call it as
  desired:

  \`\`\`
  const {defaultRuntimeEval} = require("kame");

  exports.evaluate = function myEval(code, filepath) {
    return defaultRuntimeEval.evaluate("var ENV = 'dev'; " + code, filepath);
  };
  \`\`\`



--code-splitting-id: A globally-unique id used for code splitting.

  > This option is only used when bundling code via \`kame bundle\`, not when
  > running code via \`kame run\`.

  A globally-unique id used to tie code-split chunks from this bundle to the
  correct kame instance.

  If you aren't using code-splitting (dynamic imports), you don't need to care
  about this.

  When using dynamic import syntax (\`import()\`), kame splits your code into
  separate files, some of which have generated filenames. These files are
  called "chunks".

  The first chunk that gets loaded is called the "entry" chunk. The entry chunk
  sets up a module cache and loader that other chunks then hook into in order
  to load modules at a later time. This module cache and loader is called the
  "kame instance".

  If your app loads more than one kame bundle that uses dynamic imports, then
  kame needs a way to tell some chunks "go use this kame instance" and other
  chunks "go use that kame instance".

  That's where the code-splitting id comes in. It's a globally-unique
  identifier that can be used to differentiate one kame instance from another.

  When kame compiles a bundle, every chunk in it includes the code-splitting
  id.

  The code-splitting id defaults to an autogenerated unique id. But, if you
  want your chunks to be separately cacheable for browsers (so that unchanged
  chunks don't need to be redownloaded), you'll need to set your own
  code-splitting id.
`;

if (argv.help) {
  console.log(usage);
  process.exitCode = 1;
} else {
  const inputConfig: InputConfig = {
    loader: argv.loader,
    resolver: argv.resolver,
    runtimeEval: argv.runtimeEval,
  };
  const kame = configure(inputConfig);

  if (argv._[0] === "run") {
    const input = getInput(argv);

    console.warn(
      `Running ${
        path.isAbsolute(input) ? path.relative(process.cwd(), input) : input
      }`
    );

    const runtime = new kame.Runtime();
    runtime.load(argv.input || argv._[1]);
  } else if (argv._[0] === "bundle") {
    const input = getInput(argv);
    const output = getOutput(argv);

    let globalName = argv.global;
    if (globalName === undefined) globalName = null;
    if (globalName === "null") globalName = null;

    const codeSplittingId = argv.codeSplittingId || undefined;

    const bundler = new kame.Bundler();
    const { warnings, writtenFiles } = bundler.bundle({
      input,
      output,
      globalName,
      codeSplittingId,
    });

    warnings.forEach((warning) => {
      console.warn(warning);
    });
    console.warn(chalk.blue("Files created:"));
    writtenFiles.forEach((file) => {
      console.log(path.relative(process.cwd(), file));
    });
  } else {
    console.error(`Unknown command: ${argv._[0]}\n`);
    console.error(usage);
    process.exitCode = 1;
  }
}
